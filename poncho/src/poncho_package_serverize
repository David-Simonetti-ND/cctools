#!/usr/bin/env python3

# Copyright (C) 2022- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.


from poncho import poncho_package_analyze as analyze
from poncho import poncho_package_create as create
import argparse
import json
import tempfile
import inspect
import importlib
import shutil
import os
import sys

network_code = \
'''#! /usr/bin/env python

import socket
import json
import os
import sys
import threading
import queue

def remote_execute(func):
    def remote_wrapper(event, q=None):
        if q:
            event = json.loads(event)
            del event["exec_method"]
        try:
            response = {
                "Result": func(**event),
                "StatusCode": 200
            }
        except Exception as e:
            response = { 
                "Result": str(e),
                "StatusCode": 500 
            }
        if not q:
            return response
        q.put(response)
    return remote_wrapper

read, write = os.pipe() 

def send_configuration(config):
    config_string = json.dumps(config)
    print(len(config_string) + 1, \"\\n\", config_string, flush=True)

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # modify the port argument to be 0 to listen on an arbitrary port
        s.bind(('localhost', 0))
    except Exception as e:
        s.close()
        print(e)
        exit(1)

    # information to print to stdout for worker
    config = {
            "name": name(),
            "port": s.getsockname()[1],
            }

    send_configuration(config)

    while True:
        s.listen()
        conn, addr = s.accept()
        print('Network function: connection from {}'.format(addr), file=sys.stderr)
        while True:
            # peek at message to find newline to get the size
            event_size = None
            line = conn.recv(100, socket.MSG_PEEK)
            eol = line.find(b'\\n')
            if eol >= 0:
                size = eol+1
                # actually read the size of the event
                input_spec = conn.recv(size).decode('utf-8').split()
                function_name = input_spec[0]
                event_size = int(input_spec[1])
            try:
                if event_size:
                    # receive the bytes containing the event and turn it into a string
                    event_str = conn.recv(event_size).decode("utf-8")
                    # turn the event into a python dictionary
                    event = json.loads(event_str)
                    # see if the user specified an execution method
                    exec_method = event.get("exec_method", None)
                    print('Network function: recieved event: {}'.format(event), file=sys.stderr)
                    if exec_method == "thread":
                        # create a forked process for function handler
                        q = queue.Queue()
                        p = threading.Thread(globals()[function_name], args=(event_str, q))
                        p.start()
                        p.join()
                        response = json.dumps(q.get()).encode("utf-8")
                    elif exec_method == "direct":
                        del event["exec_method"]
                        response = json.dumps(globals()[function_name](event)).encode("utf-8")
                    else:
                        event.pop("exec_method", None)
                        p = os.fork()
                        if p == 0:
                            response = globals()[function_name](event)
                            os.write(write, json.dumps(response).encode("utf-8"))
                            os._exit(-1)
                        elif p < 0:
                            print('Network function: unable to fork', file=sys.stderr)
                            response = { 
                                "Result": "unable to fork",
                                "StatusCode": 500 
                            }
                        else:
                            chunk = os.read(read, 65536).decode("utf-8")
                            all_chunks = [chunk]
                            while (len(chunk) >= 65536):
                                chunk = os.read(read, 65536).decode("utf-8")
                                all_chunks.append(chunk)
                            response = "".join(all_chunks).encode("utf-8")
                            os.waitid(os.P_PID, p, os.WEXITED)

                    response_size = len(response)

                    size_msg = "output {}\\n".format(response_size)

                    # send the size of response
                    conn.sendall(size_msg.encode('utf-8'))

                    # send response
                    conn.sendall(response)

                    break
            except Exception as e:
                print("Network function encountered exception ", str(e), file=sys.stderr)
    return 0

'''
default_name_func = \
'''def name():
	return "my_coprocess"

'''
init_function = \
'''if __name__ == "__main__":
	main()

'''

def create_network_function(path, funcs, dest):
	absolute_path = os.path.abspath(path)
	with tempfile.TemporaryDirectory() as temp_package_dir:
		# get filename from path
		filename = absolute_path.split("/")[-1].replace(".py", "")
		# create a temporary directory to turn the users input python file into a module that we can then load
		os.mkdir(f"{temp_package_dir}/{filename}")
		# see if the input valid is valid
		try: 
			path_to_module = shutil.copy(absolute_path, f"{temp_package_dir}/{filename}/{filename}.py")
		except:
			print("Error, input file does not exist")
			exit()
		# create an empty file with the name __init__.py to tell python that there is a module there
		open(f"{temp_package_dir}/{filename}/__init__.py", "w").close()
		# load in the module
		spec = importlib.util.spec_from_file_location(filename, path_to_module)
		module = importlib.util.module_from_spec(spec)
		sys.modules["module.name"] = module
		spec.loader.exec_module(module)
		# get the name function that must be defined in the code
		try:
			name_func = inspect.getsource(getattr(module, "name"))
		except:
			print("No name function found, defaulting to my_coprocess")
			name_func = default_name_func
		# create output file
		output_file = open(dest, "w")
		# write network code into it
		output_file.write(network_code)
		# write name function code into it
		output_file.write(name_func)
		# iterate over every function the user requested and attempt to put it into the network function
		for func in funcs:
			try:
				remote_func = inspect.getsource(getattr(module, func))
				output_file.write("@remote_execute\n")
				output_file.write(remote_func)
				output_file.write("\n")
			except:
				print(f"Function {func} not found in input file, skipping")
		output_file.write(init_function)
		output_file.close()
		

def MakeNetworkFunction(filename, func, keep_data=False):

	function_name = filename.func.__name__
	#env = analyze.create_spec(filename, function=function_name)

	print(json.dumps(env, indent=4, sort_keys=True))

	with open('tmp.json', 'w') as f:
		json.dump(env, f, indent=4, sort_keys=True)

	#pkg = create.pack_env('tmp.json', 'tmp.tar.gz', serverless=True, function=func)

	#return pkg
if __name__ == "__main__":
	parser = argparse.ArgumentParser(description="Creates a network function based on an input file and function")
	parser.add_argument('--source', help='Source file that contains the function to be serverized')
	parser.add_argument('--function', action='append', help='Name of the function in filename to be serverized')
	parser.add_argument('--pack', action='store_true', help='Pack network function into an environemnt')
	parser.add_argument('--out', help='Output file for network function')
	args = parser.parse_args()
	print(args)
	if args.function is None:
		print("Error, must specify at least one function")
		exit()
	if not args.pack:
		create_network_function(args.source, args.function, args.out)